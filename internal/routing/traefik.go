package routing

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"gopkg.in/yaml.v3"
)

// TraefikGenerator writes Traefik dynamic config from service state.
type TraefikGenerator struct {
	outputPath string
	mu         sync.Mutex
}

// NewTraefikGenerator creates a generator that writes to the given path.
func NewTraefikGenerator(outputPath string) *TraefikGenerator {
	return &TraefikGenerator{outputPath: outputPath}
}

// ServiceRoute describes a running service that needs routing.
type ServiceRoute struct {
	Name       string
	Hostname   string
	Port       int
	TLS        bool
	TLSOptions string // e.g. "mtls" — references a TLS options block in Traefik's static config
}

// Generate writes a Traefik dynamic config file for the given routes.
// Services that are not running or have no routing config are excluded.
func (g *TraefikGenerator) Generate(routes []ServiceRoute) error {
	g.mu.Lock()
	defer g.mu.Unlock()

	cfg := g.buildConfig(routes)

	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("marshaling traefik config: %w", err)
	}

	// Add a header comment
	out := []byte("# Auto-generated by aurelia — do not edit\n")
	out = append(out, data...)

	if err := os.MkdirAll(filepath.Dir(g.outputPath), 0755); err != nil {
		return fmt.Errorf("creating output dir: %w", err)
	}

	return os.WriteFile(g.outputPath, out, 0644)
}

// OutputPath returns the path where config is written.
func (g *TraefikGenerator) OutputPath() string {
	return g.outputPath
}

// traefikConfig is the top-level Traefik dynamic config structure.
type traefikConfig struct {
	HTTP *traefikHTTP `yaml:"http,omitempty"`
}

type traefikHTTP struct {
	Routers  map[string]*traefikRouter  `yaml:"routers,omitempty"`
	Services map[string]*traefikService `yaml:"services,omitempty"`
}

type traefikRouter struct {
	Rule        string   `yaml:"rule"`
	EntryPoints []string `yaml:"entryPoints"`
	Service     string   `yaml:"service"`
	TLS         *traefikRouterTLS `yaml:"tls,omitempty"`
}

type traefikRouterTLS struct {
	Options string `yaml:"options,omitempty"`
}

type traefikService struct {
	LoadBalancer *traefikLoadBalancer `yaml:"loadBalancer"`
}

type traefikLoadBalancer struct {
	Servers []traefikServer `yaml:"servers"`
}

type traefikServer struct {
	URL string `yaml:"url"`
}

func (g *TraefikGenerator) buildConfig(routes []ServiceRoute) traefikConfig {
	if len(routes) == 0 {
		return traefikConfig{}
	}

	routers := make(map[string]*traefikRouter)
	services := make(map[string]*traefikService)

	for _, r := range routes {
		routerName := sanitizeName(r.Name)
		serviceName := sanitizeName(r.Name)

		router := &traefikRouter{
			Rule:        fmt.Sprintf("Host(`%s`)", r.Hostname),
			Service:     serviceName,
		}

		if r.TLS {
			router.EntryPoints = []string{"websecure"}
			router.TLS = &traefikRouterTLS{}
			if r.TLSOptions != "" {
				router.TLS.Options = r.TLSOptions + "@file"
			}
		} else {
			router.EntryPoints = []string{"web"}
		}

		routers[routerName] = router

		scheme := "http"
		services[serviceName] = &traefikService{
			LoadBalancer: &traefikLoadBalancer{
				Servers: []traefikServer{
					{URL: fmt.Sprintf("%s://127.0.0.1:%d", scheme, r.Port)},
				},
			},
		}
	}

	return traefikConfig{
		HTTP: &traefikHTTP{
			Routers:  routers,
			Services: services,
		},
	}
}

// sanitizeName converts a service name to a Traefik-safe identifier.
// Traefik names must be alphanumeric + hyphens.
func sanitizeName(name string) string {
	return strings.ReplaceAll(name, "_", "-")
}
